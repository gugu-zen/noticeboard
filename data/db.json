{
  "notes": [
    {
      "title": "useEffect",
      "details": "useEffect is the hook that manages the side-effects in functional components. callback argument is a function to put the side-effect logic. dependencies is a list of dependencies of your side-effect: being props or state values.",
      "category": "Popular",
      "file": " ",
      "id": 2
    },
    {
      "title": "useHistory",
      "category": "Popular",
      "details": "The useHistory hook gives you access to the history instance that you may use to navigate.",
      "file": "",
      "id": 3
    },
    {
      "title": "useLocation",
      "category": "Notice",
      "details": "The useLocation hook returns the location object that represents the current URL. You can think about it like a useState that returns a new location whenever the URL changes. This could be really useful e.g. in a situation where you would like to trigger a new “page view” event using your web analytics tool whenever a new page loads.",
      "file": "",
      "id": 4
    },
    {
      "title": "useParams",
      "category": "Event",
      "details": "useParams returns an object of key/value pairs of URL parameters. Use it to access match.params of the current <Route>.",
      "file": "",
      "id": 5
    },
    {
      "title": "useRouteMatch",
      "category": "Advertisement",
      "details": "The useRouteMatch hook attempts to match the current URL in the same way that a <Route> would. It’s mostly useful for getting access to the match data without actually rendering a <Route>.",
      "file": "",
      "id": 6
    },
    {
      "title": "useState",
      "category": "Notice",
      "details": "useState is a Hook that allows you to have state variables in functional components. You pass the initial state to this function and it returns a variable with the current state value (not necessarily the initial state) and another function to update this value.",
      "file": "",
      "id": 7
    }
  ]
}